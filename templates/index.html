<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker Grid</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}?v=2">
</head>
<body>
    <div class="page-container">
        <div class="grid-container page page-1 active">
        <div class="grid-item item-1">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>字符替换</h2>
                <div style="height: 40%;">
                    <form method="POST" action="/">
                        <div class="input-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <input type="text" name="text" placeholder=">_" autocomplete="off" autofocus style="width: 100%;">
                            <div style="display: flex; gap: 5px; width: 100%;">
                                <button type="submit" name="action" value="add" style="flex: 1;">+</button>
                                <button type="submit" name="action" value="remove" style="flex: 1;">-</button>
                            </div>
                        </div>
                    </form>
                </div>
                <div style="height: 60%; border-top: 1px solid var(--border-color); overflow-y: auto; padding-top: 5px;">
                     <div class="substitution-content" style="word-break: break-all;">
                        {{ substitutions }}
                    </div>
                </div>
            </div>
        </div>
        
        <div class="grid-item item-2">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2 style="display: flex; align-items: center;">
                    连接状态
                    <span id="connStatusLight" style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: gray; box-shadow: 0 0 2px gray; margin-left: 10px;"></span>
                </h2>
                <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div style="font-size: 0.8rem; margin-bottom: 10px; color: #888;">CURRENT IP</div>
                    <div id="currentIp" style="font-size: 1.1rem; color: #0f0; margin-bottom: 20px; font-weight: bold; word-break: break-all; text-align: center;">LOADING...</div>
                    <button id="retestBtn" class="action-btn" onclick="retestConnection()" style="width: 80%;">RETEST CONNECTION</button>
                    <div id="retestStatus" style="font-size: 0.7rem; margin-top: 5px; height: 1em;"></div>
                </div>
            </div>
        </div>

        <div class="grid-item item-3">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>角色上传</h2>
                <div style="margin-top: 5px; font-size: 0.8rem; color: #ff0000;">当前角色</div>
                <form id="charUploadForm" action="/upload_character" method="post" enctype="multipart/form-data">
                    <input type="file" name="file" accept="image/png, image/jpeg, image/webp" 
                           class="upload-input">
                    <button type="submit" id="charUploadBtn" class="action-btn">UPLOAD CHARACTER</button>
                </form>
                <div id="charStatus" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>

        <div class="grid-item item-4">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>角色输出 <button type="button" class="inline-refresh-btn" onclick="refreshCharacter()" aria-label="刷新当前角色"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button></h2>
                <div id="outputContainer" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <!-- Character Preview (Initially Hidden) -->
                    <img id="charPreview" src="http://obs.dimond.top/character.png" 
                         style="max-width: 90%; max-height: 90%; border: 1px solid #00ff00; object-fit: contain; display: none;"
                         onload="this.style.display='block'"
                         onerror="this.style.display='none'">
                    <!-- Video Output will be injected here via JS -->
                </div>
            </div>
        </div>

        <div class="grid-item item-5">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>视频裁剪</h2>
                <form id="uploadForm" action="/upload_and_cut" method="post" enctype="multipart/form-data">
                    <div style="margin-bottom: 5px;">
                        <label style="margin-right: 10px;"><input type="radio" name="workflow_type" value="real" checked> 真人</label>
                        <label><input type="radio" name="workflow_type" value="anime"> 动漫</label>
                    </div>
                    <input type="file" name="video" accept="video/*" class="upload-input">
                    <button type="submit" id="uploadBtn" class="action-btn">EXECUTE</button>
                </form>
                <div id="uploadStatus" style="margin-top: 10px; font-size: 0.8em; white-space: pre-wrap; word-break: break-all;"></div>
            </div>
        </div>

        <div class="grid-item item-6">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>
                    <a href="http://obs.dimond.top" target="_blank" style="color: inherit; text-decoration: none;">OBS预览</a>
                    <button type="button" class="inline-refresh-btn" onclick="updateLatestVideo(true)" aria-label="刷新当前视频">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                    </button>
                    <button type="button" id="saveCharacterFromCurrentBtn" class="inline-refresh-btn" onclick="saveCharacterFromCurrentVideo()" aria-label="保存当前视频前10秒为 character.mp4 并上传OBS">
                        +
                    </button>
                </h2>
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <video id="latestVideoPreview" preload="metadata" autoplay muted loop controls style="width: 100%; height: 100%; object-fit: contain; border: 1px solid #00ff00; background: #000;">
                        Your browser does not support the video tag.
                    </video>
                </div>
            </div>
        </div>

        <div class="grid-item item-7">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>音频生成</h2>
                <form id="audioUploadForm" action="/upload_audio" method="post" enctype="multipart/form-data">
                    <div style="margin-bottom: 5px;">
                        <input type="text" name="text" placeholder="输入生成的文本" class="upload-input" style="width: 100%; box-sizing: border-box; margin-bottom: 0; margin-top: 0;" required>
                    </div>
                    <div style="margin-bottom: 5px; font-size: 0.8em; display: flex; flex-wrap: wrap; gap: 5px;">
                        <label><input type="checkbox" name="emotions" value="Happy"> Happy</label>
                        <label><input type="checkbox" name="emotions" value="Angry"> Angry</label>
                        <label><input type="checkbox" name="emotions" value="Sad"> Sad</label>
                        <label><input type="checkbox" name="emotions" value="Fear"> Fear</label>
                    </div>
                    <div style="margin-bottom: 5px;">
                        <input type="file" name="file" accept="audio/*, .mov, .mp4" class="upload-input">
                    </div>
                    <button type="submit" id="audioUploadBtn" class="action-btn" style="white-space: nowrap;">GENERATE AUDIO</button>
                </form>
                <div id="audioStatus" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-8">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2><a href="http://obs.dimond.top" target="_blank" style="color: inherit; text-decoration: none;">OBS音频预览</a> <button type="button" class="inline-refresh-btn" onclick="updateLatestAudio(true)" aria-label="刷新当前音频"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h-6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button></h2>
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <audio id="latestAudioPreview" controls style="width: 90%;">
                        Your browser does not support the audio element.
                    </audio>
                    <div id="latestAudioName" style="margin-top: 10px; font-size: 0.7em; word-break: break-all;"></div>
                </div>
            </div>
        </div>
        </div>

        <div class="grid-container page page-2">
        <div class="grid-item item-9">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>图生视频</h2>
                <div class="i2v-container">
                    <select id="i2vGroupSelect9" class="upload-input" style="width: 100%; margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="text" id="i2vText9" class="upload-input i2v-text-input" placeholder="输入图生视频脚本" style="width: 100%;">
                    <button type="button" class="action-btn" onclick="submitI2V(9)">SUBMIT</button>
                </div>
                <div id="i2vStatus9" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-10">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>图生视频</h2>
                <div class="i2v-container">
                    <select id="i2vGroupSelect10" class="upload-input" style="width: 100%; margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="text" id="i2vText10" class="upload-input i2v-text-input" placeholder="输入图生视频脚本" style="width: 100%;">
                    <button type="button" class="action-btn" onclick="submitI2V(10)">SUBMIT</button>
                </div>
                <div id="i2vStatus10" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>

        <div class="grid-item item-11">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>图生视频</h2>
                <div class="i2v-container">
                    <select id="i2vGroupSelect11" class="upload-input" style="width: 100%; margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="text" id="i2vText11" class="upload-input i2v-text-input" placeholder="输入图生视频脚本" style="width: 100%;">
                    <button type="button" class="action-btn" onclick="submitI2V(11)">SUBMIT</button>
                </div>
                <div id="i2vStatus11" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-12">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>图生视频</h2>
                <div class="i2v-container">
                    <select id="i2vGroupSelect12" class="upload-input" style="width: 100%; margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="text" id="i2vText12" class="upload-input i2v-text-input" placeholder="输入图生视频脚本" style="width: 100%;">
                    <button type="button" class="action-btn" onclick="submitI2V(12)">SUBMIT</button>
                </div>
                <div id="i2vStatus12" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-13">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>视频转场</h2>
                <form id="transitionForm13" enctype="multipart/form-data">
                    <select id="transitionGroupSelect13" name="group_id" class="upload-input" style="margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="file" name="video" accept="video/*" class="upload-input">
                    <button type="submit" class="action-btn">SUBMIT</button>
                </form>
                <div id="transitionStatus13" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-14">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>视频转场</h2>
                <form id="transitionForm14" enctype="multipart/form-data">
                    <select id="transitionGroupSelect14" name="group_id" class="upload-input" style="margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="file" name="video" accept="video/*" class="upload-input">
                    <button type="submit" class="action-btn">SUBMIT</button>
                </form>
                <div id="transitionStatus14" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-15">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>视频转场</h2>
                <form id="transitionForm15" enctype="multipart/form-data">
                    <select id="transitionGroupSelect15" name="group_id" class="upload-input" style="margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="file" name="video" accept="video/*" class="upload-input">
                    <button type="submit" class="action-btn">SUBMIT</button>
                </form>
                <div id="transitionStatus15" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        <div class="grid-item item-16">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
            </div>
            <div class="grid-content">
                <h2>视频转场</h2>
                <form id="transitionForm16" enctype="multipart/form-data">
                    <select id="transitionGroupSelect16" name="group_id" class="upload-input" style="margin-bottom: 5px;">
                        <option value="new">New Group (Auto)</option>
                    </select>
                    <input type="file" name="video" accept="video/*" class="upload-input">
                    <button type="submit" class="action-btn">SUBMIT</button>
                </form>
                <div id="transitionStatus16" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>
        </div>
        <div class="grid-container page page-3">
            <div class="grid-item item-17">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>台词扩写</h2>
                    <div class="i2v-container">
                        <input type="text" id="sector17Input" class="upload-input i2v-text-input" placeholder="输入台词或关键词" style="width: 100%;">
                        <button type="button" class="action-btn" onclick="submitSector17()">SUBMIT</button>
                    </div>
                    <div id="sector17Status" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap; overflow-y: auto; max-height: 150px; text-align: left;"></div>
                </div>
            </div>
            <div class="grid-item item-18">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>提示词代写 <button type="button" class="inline-refresh-btn" onclick="refreshSector18()" aria-label="刷新"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button></h2>
                    <textarea id="sector18Text" style="width: 100%; height: 60%; background: #000; color: #0f0; border: 1px solid #333; font-family: 'Courier New', monospace; resize: none;" readonly></textarea>
                    <button type="button" class="action-btn" onclick="copySector18()" style="margin-top: 5px;">COPY TO CLIPBOARD</button>
                    <div id="sector18Status" style="margin-top: 2px; font-size: 0.7em;"></div>
                </div>
            </div>
            <div class="grid-item item-19">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>视频分析</h2>
                    <form id="sector19Form" style="display: flex; flex-direction: column; height: 80%;">
                        <input type="file" name="video" accept="video/*" class="upload-input" style="margin-bottom: 5px;">
                        <button type="submit" class="action-btn">ANALYZE</button>
                        <div id="sector19Status" style="margin-top: 5px; font-size: 0.7em; overflow-y: auto; flex-grow: 1; white-space: pre-wrap; text-align: left;"></div>
                    </form>
                </div>
            </div>
            <div class="grid-item item-20">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector20</h2>
                </div>
            </div>
            <div class="grid-item item-21">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector21</h2>
                </div>
            </div>
            <div class="grid-item item-22">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector22</h2>
                </div>
            </div>
            <div class="grid-item item-23">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector23</h2>
                </div>
            </div>
            <div class="grid-item item-24">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector24</h2>
                </div>
            </div>
        </div>

        <div class="grid-container page page-4">
            <div class="grid-item item-25">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector25</h2>
                </div>
            </div>
            <div class="grid-item item-26">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector26</h2>
                </div>
            </div>
            <div class="grid-item item-27">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector27</h2>
                </div>
            </div>
            <div class="grid-item item-28">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector28</h2>
                </div>
            </div>
            <div class="grid-item item-29">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector29</h2>
                </div>
            </div>
            <div class="grid-item item-30">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector30</h2>
                </div>
            </div>
            <div class="grid-item item-31">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector31</h2>
                </div>
            </div>
            <div class="grid-item item-32">
                <div class="grid-controls">
                    <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                </div>
                <div class="grid-content">
                    <h2>Sector32</h2>
                </div>
            </div>
        </div>
    </div>

    <div class="page-nav-bar">
        <div class="page-nav-zone page-nav-prev" onclick="goPrevPage()" style="cursor: pointer;">◀ PREV</div>
        <div class="page-nav-zone page-nav-next" onclick="goNextPage()" style="cursor: pointer;">NEXT ▶</div>
    </div>

    <script>
        var videoCache = new Map();

        // Fullscreen Logic
        function goFullscreen(elem) {
            elem.classList.add('fullscreen');
        }

        function exitFullscreen(elem) {
            elem.classList.remove('fullscreen');
        }

        var currentPage = 1;
        var totalPages = 4;
        var touchStartX = 0;
        var touchEndX = 0;

        function updatePageVisibility() {
            console.log('Updating visibility. Current Page:', currentPage);
            var pages = document.querySelectorAll('.page');
            console.log('Found pages:', pages.length);
            pages.forEach(function (p, idx) {
                if (idx === currentPage - 1) {
                    p.classList.add('active');
                    console.log('Page ' + (idx+1) + ' set to active');
                } else {
                    p.classList.remove('active');
                    console.log('Page ' + (idx+1) + ' set to inactive');
                }
            });
        }

        function goToPage(page) {
            console.log('Going to page:', page);
            if (page < 1) page = 1;
            if (page > totalPages) page = totalPages;
            currentPage = page;
            updatePageVisibility();
        }

        function goPrevPage() {
            console.log('goPrevPage called');
            goToPage(currentPage - 1);
        }

        function goNextPage() {
            console.log('goNextPage called');
            goToPage(currentPage + 1);
        }

        document.querySelector('.page-nav-prev').addEventListener('click', goPrevPage);
        document.querySelector('.page-nav-next').addEventListener('click', goNextPage);

        document.addEventListener('touchstart', function (e) {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
            }
        }, { passive: true });

        document.addEventListener('touchend', function (e) {
            touchEndX = e.changedTouches[0].clientX;
            var dx = touchEndX - touchStartX;
            if (Math.abs(dx) > 50) {
                if (dx < 0) {
                    goNextPage();
                } else {
                    goPrevPage();
                }
            }
        }, { passive: true });

        updatePageVisibility();

        // Check ComfyUI Status
        function checkComfyStatus() {
            fetch('/comfy_status')
                .then(response => response.json())
                .then(data => {
                    const dot = document.getElementById('connStatusLight');
                    const ipDiv = document.getElementById('currentIp');
                    
                    if (data.status === 'online') {
                        dot.style.backgroundColor = '#00ff00'; // Green
                        dot.style.boxShadow = '0 0 5px #00ff00';
                        ipDiv.innerText = data.ip || 'Unknown';
                        ipDiv.style.color = '#00ff00';
                    } else {
                        dot.style.backgroundColor = '#ff0000'; // Red
                        dot.style.boxShadow = '0 0 5px #ff0000';
                        ipDiv.innerText = data.ip || 'DISCONNECTED';
                        ipDiv.style.color = '#ff0000';
                    }
                })
                .catch(err => {
                    console.error('Status check failed:', err);
                    const dot = document.getElementById('connStatusLight');
                    const ipDiv = document.getElementById('currentIp');
                    dot.style.backgroundColor = 'gray';
                    ipDiv.innerText = 'ERROR';
                    ipDiv.style.color = 'gray';
                });
        }
        
        function retestConnection() {
            const btn = document.getElementById('retestBtn');
            const statusDiv = document.getElementById('retestStatus');
            btn.disabled = true;
            statusDiv.innerText = 'TESTING...';
            
            fetch('/retest_connection', { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                         statusDiv.innerText = 'DONE';
                         checkComfyStatus(); // Refresh UI
                    } else {
                        statusDiv.innerText = 'FAILED';
                    }
                })
                .catch(e => {
                    statusDiv.innerText = 'ERROR: ' + e.message;
                })
                .finally(() => {
                    btn.disabled = false;
                    setTimeout(() => { statusDiv.innerText = ''; }, 3000);
                });
        }
        
        // Check immediately and then every 30 seconds
        checkComfyStatus();
        setInterval(checkComfyStatus, 30000);

        // Character Upload Handler
        document.getElementById('charUploadForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('charStatus');
            const btn = document.getElementById('charUploadBtn');
            const preview = document.getElementById('charPreview');
            
            statusDiv.innerText = 'UPLOADING...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_character', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                
                if (response.ok) {
                    statusDiv.innerText = 'UPLOAD SUCCESS.';
                    // Update preview with cache busting
                    if (preview) {
                        preview.src = result.url + '?t=' + new Date().getTime();
                        preview.style.display = 'block';
                    }
                } else {
                    statusDiv.innerText = 'ERROR: ' + (result.error || 'Unknown');
                }
            } catch (err) {
                statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
            } finally {
                btn.disabled = false;
            }
        };

        // Video Upload Handler
        document.getElementById('uploadForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('uploadStatus');
            const btn = document.getElementById('uploadBtn');
            
            statusDiv.innerText = 'INITIALIZING UPLOAD...\nTARGET: COMFYUI NODE';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_and_cut', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                
                if (response.ok) {
                     statusDiv.innerText = 'UPLOAD SUCCESS. PROCESSING SEQUENCE INITIATED...';
                     
                     // Start polling
                     const groupId = result.group_id;
                     const pollInterval = setInterval(async () => {
                         try {
                             const statusRes = await fetch(`/check_group_status/${groupId}`);
                             const statusData = await statusRes.json();
                             
                             if (statusData.status === 'processing') {
                                 statusDiv.innerText = `PROCESSING... [${statusData.progress}]`;
                             } else if (statusData.status === 'completed') {
                                 clearInterval(pollInterval);
                                statusDiv.innerText = 'SEQUENCE COMPLETED.\nESTABLISHING LINK TO SECTOR 04...';
                                btn.disabled = false;
                                
                                // Display video in Sector 04 (replacing character preview or appending?)
                                // Request says Grid 4 should display the result. 
                                // We can replace the content of outputContainer or hide charPreview.
                                const outputContainer = document.getElementById('outputContainer');
                                const charPreview = document.getElementById('charPreview');
                                if (charPreview) charPreview.style.display = 'none'; // Hide char preview
                                
                                // Remove old video if exists
                                const oldVideo = outputContainer.querySelector('video');
                                if (oldVideo) oldVideo.remove();
                                
                                const videoContainer = document.createElement('div');
                                videoContainer.innerHTML = `
                                    <h2>OUTPUT FEED</h2>
                                    <video controls preload="metadata" autoplay muted loop style="width: 100%; max-height: 200px; border: 1px solid #00ff00; background: #000;">
                                        <source src="${statusData.final_url}" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>
                                    <div style="margin-top: 5px; font-size: 0.7em; word-break: break-all;">${statusData.final_url}</div>
                                `;
                                outputContainer.appendChild(videoContainer);
                                
                            } else {
                                 clearInterval(pollInterval);
                                 statusDiv.innerText = 'FAILED: ' + (statusData.error || 'Unknown error');
                                 btn.disabled = false;
                             }
                         } catch (e) {
                             console.error(e);
                             // Don't stop polling on transient network errors, but maybe show warning?
                         }
                     }, 2000);
                     
                 } else {
                     statusDiv.innerText = 'ERROR: ' + (result.error || 'Unknown');
                     btn.disabled = false;
                 }
             } catch (err) {
                 statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
                 btn.disabled = false;
             }
         };

        // Fetch latest video for Grid 7
        function updateLatestVideo(force = false) {
            fetch('/latest_video')
                .then(response => response.json())
                .then(data => {
                    if (data.url) {
                        const video = document.getElementById('latestVideoPreview');
                        // Only update if source changed to avoid flickering, unless forced
                        if (force || !video.src.includes(data.url)) {
                            // Add timestamp if forced or just to be safe if url is same
                            const newSrc = force ? data.url + "?t=" + new Date().getTime() : data.url;
                            if (video.src !== newSrc) {
                                // Pause current video before changing source to prevent stuttering
                                const wasPaused = video.paused;
                                const currentTime = video.currentTime; // Preserve playback position
                                video.pause();
                                
                                // Use video caching to improve performance
                                if (videoCache.has(newSrc)) {
                                    video.src = videoCache.get(newSrc);
                                } else {
                                    video.src = newSrc;
                                    // Cache the source URL for future reference
                                    videoCache.set(newSrc, newSrc);
                                }
                                
                                // Restore playback state if video was playing
                                if (!wasPaused && force) {
                                    video.currentTime = currentTime; // Restore position
                                    video.play().catch(e => console.log('Auto-play prevented by browser policies'));
                                }
                            }
                        }
                    }
                })
                .catch(err => console.error('Error fetching latest video:', err));
        }

        async function saveCharacterFromCurrentVideo() {
            const btn = document.getElementById('saveCharacterFromCurrentBtn');
            if (!btn) return;
            btn.disabled = true;
            try {
                const res = await fetch('/save_character_from_current', { method: 'POST' });
                const data = await res.json();
                if (res.ok) {
                    alert('character.mp4 已上传到 OBS');
                } else {
                    alert('保存失败: ' + (data.error || 'Unknown'));
                }
            } catch (e) {
                alert('系统错误: ' + e.message);
            } finally {
                btn.disabled = false;
            }
        }
        
        // Check for latest video every 30 seconds
        updateLatestVideo();
        setInterval(updateLatestVideo, 30000);

        // Character Refresh Logic
        function refreshCharacter() {
            const preview = document.getElementById('charPreview');
            if (preview) {
                preview.src = "http://obs.dimond.top/character.png?t=" + new Date().getTime();
                preview.style.display = 'block';
            }
        }

        // Transition Group Logic with SessionStorage
        function getGroupId() {
            return sessionStorage.getItem('transition_group_id');
        }

        function setGroupId(id) {
            sessionStorage.setItem('transition_group_id', id);
            syncTransitionDropdowns(id);
        }

        function syncTransitionDropdowns(id) {
            if (!id) return;
            ['13', '14', '15', '16'].forEach(function(num) {
                var sel = document.getElementById('transitionGroupSelect' + num);
                if (sel) {
                    // Check if option exists, if not, wait for fetch or add it?
                    // We assume fetchGroupOptions is called when 'new' is used.
                    // If the id is not in options, setting value won't work.
                    // But usually we call fetchGroupOptions then setGroupId.
                    if (sel.value !== id) {
                        sel.value = id;
                    }
                }
            });
        }

        // Initialize display on load
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for initial fetch to complete before setting initial value
            fetchGroupOptions().then(() => {
                var savedId = getGroupId();
                if (savedId) {
                    syncTransitionDropdowns(savedId);
                }
            });
        });

        // Add change listeners to transition dropdowns
        ['13', '14', '15', '16'].forEach(function(num) {
            var sel = document.getElementById('transitionGroupSelect' + num);
            if (sel) {
                sel.addEventListener('change', function() {
                    if (this.value !== 'new') {
                        setGroupId(this.value);
                    }
                });
            }
        });

        var transitionPollTimer = null;

        // UUID Generator
        function generateUUID() {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function setupTransitionForm(formId, statusId) {
            var form = document.getElementById(formId);
            var statusDiv = document.getElementById(statusId);
            if (!form || !statusDiv) return;
            form.onsubmit = async function (e) {
                e.preventDefault();
                var btn = form.querySelector('button[type="submit"]');
                var formData = new FormData(form);
                
                var selectEl = form.querySelector('select[name="group_id"]');
                var selectedId = selectEl ? selectEl.value : 'new';
                
                statusDiv.innerText = 'UPLOADING...';
                if (btn) btn.disabled = true;
                try {
                    var resp = await fetch('/upload_transition_video', {
                        method: 'POST',
                        body: formData
                    });
                    var data = await resp.json();
                    if (resp.ok) {
                        if (data.group_id) {
                            if (selectedId === 'new') {
                                await fetchGroupOptions();
                            }
                            setGroupId(data.group_id);
                        }
                        statusDiv.innerText = 'SUBMITTED.';
                        if (getGroupId() && !transitionPollTimer) {
                            startTransitionStatusPolling();
                        }
                    } else {
                        statusDiv.innerText = 'ERROR: ' + (data.error || 'Unknown');
                    }
                } catch (err) {
                    statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
                } finally {
                    if (btn) btn.disabled = false;
                }
            };
        }

        function startTransitionStatusPolling() {
            var gid = getGroupId();
            if (!gid) return;
            if (transitionPollTimer) return;
            var statusDivs = [
                document.getElementById('transitionStatus13'),
                document.getElementById('transitionStatus14'),
                document.getElementById('transitionStatus15'),
                document.getElementById('transitionStatus16')
            ];
            
            transitionPollTimer = setInterval(function () {
                var currentGid = getGroupId();
                if (!currentGid) {
                    clearInterval(transitionPollTimer);
                    transitionPollTimer = null;
                    return;
                }

                fetch('/check_group_status/' + currentGid)
                    .then(function (r) { return r.json(); })
                    .then(function (s) {
                        statusDivs.forEach(function(div) {
                            if (!div) return;
                            if (s.status === 'processing') {
                                div.innerText = 'TRANSITION PROCESSING... [' + (s.progress || '') + ']';
                            } else if (s.status === 'completed') {
                                // Don't clear timer immediately if we want to keep showing completed?
                                // But maybe we should stop polling.
                                // Let's keep showing completed.
                                div.innerText = 'TRANSITION COMPLETED.';
                            } else if (s.status === 'failed') {
                                div.innerText = 'TRANSITION FAILED: ' + (s.error || 'Unknown');
                            }
                        });

                        if (s.status === 'completed' || s.status === 'failed') {
                             clearInterval(transitionPollTimer);
                             transitionPollTimer = null;
                             if (s.status === 'completed' && s.final_url) {
                                updateLatestVideo(true);
                             }
                        }
                    })
                    .catch(function () {
                    });
            }, 2000);
        }

        setupTransitionForm('transitionForm13', 'transitionStatus13');
        setupTransitionForm('transitionForm14', 'transitionStatus14');
        setupTransitionForm('transitionForm15', 'transitionStatus15');
        setupTransitionForm('transitionForm16', 'transitionStatus16');

        // Audio Upload Handler
        document.getElementById('audioUploadForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('audioStatus');
            const btn = document.getElementById('audioUploadBtn');
            
            statusDiv.innerText = 'INITIALIZING AUDIO GENERATION...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_audio', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                
                if (response.ok) {
                    statusDiv.innerText = 'SUBMITTED. PROCESSING...';
                    
                    // Poll for status
                    pollSector7(result.prompt_id);
                    
                } else {
                    statusDiv.innerText = 'ERROR: ' + (result.error || 'Unknown');
                    btn.disabled = false;
                }
            } catch (err) {
                statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
                btn.disabled = false;
            }
        };

        // Fetch latest audio for Grid 10
        function updateLatestAudio(force = false) {
            fetch('/latest_audio')
                .then(response => response.json())
                .then(data => {
                    if (data.url) {
                        const audio = document.getElementById('latestAudioPreview');
                        const nameDiv = document.getElementById('latestAudioName');
                        // Only update if source changed
                        if (force || !audio.src.includes(data.url)) {
                            const newSrc = force ? data.url + "?t=" + new Date().getTime() : data.url;
                            if (audio.src !== newSrc) {
                                audio.src = newSrc;
                                nameDiv.innerText = data.filename || 'sound.flac';
                            }
                        }
                    }
                })
                .catch(err => console.error('Error fetching latest audio:', err));
        }

        // Check for latest audio every 30 seconds
        updateLatestAudio();
        setInterval(updateLatestAudio, 30000);

        // Group Options Logic
        function fetchGroupOptions() {
            return fetch('/api/get_group_ids')
                .then(res => res.json())
                .then(data => {
                    const groups = data.groups || [];
                    const ids = [
                        'i2vGroupSelect9', 'i2vGroupSelect10', 'i2vGroupSelect11', 'i2vGroupSelect12',
                        'transitionGroupSelect13', 'transitionGroupSelect14', 'transitionGroupSelect15', 'transitionGroupSelect16'
                    ];
                    
                    ids.forEach(id => {
                        const sel = document.getElementById(id);
                        if (!sel) return;
                        if (document.activeElement === sel) return; // Don't update if user is interacting
                        
                        const currentVal = sel.value;
                        // Rebuild options
                        sel.innerHTML = '<option value="new">New Group (Auto-Inc)</option>';
                        groups.forEach(g => {
                            const opt = document.createElement('option');
                            opt.value = g;
                            opt.innerText = 'Group ' + g;
                            sel.appendChild(opt);
                        });
                        // Restore selection if valid
                        if (currentVal && currentVal !== 'new' && groups.includes(currentVal)) {
                            sel.value = currentVal;
                        }
                    });
                })
                .catch(e => console.error('Error fetching groups:', e));
        }

        // Fetch initially and periodically
        fetchGroupOptions();
        setInterval(fetchGroupOptions, 10000);

        async function submitI2V(index) {
            const statusDiv = document.getElementById(`i2vStatus${index}`);
            const textInput = document.getElementById(`i2vText${index}`);
            const selectEl = document.getElementById(`i2vGroupSelect${index}`);
            const text = textInput.value;
            const btn = textInput.parentElement.querySelector('button');
            const groupId = selectEl ? selectEl.value : 'new';
            
            statusDiv.innerText = 'SUBMITTING...';
            btn.disabled = true;
            
            const texts = ["", "", "", ""];
            texts[index - 9] = text;
            
            try {
                const res = await fetch('/generate_i2v_group', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({texts: texts, group_id: groupId})
                });
                const data = await res.json();
                
                if (data.status === 'processing') {
                    statusDiv.innerText = 'PROCESSING...';
                    if (groupId === 'new') {
                        await fetchGroupOptions();
                        // Update this dropdown to the new group ID
                        if (selectEl && data.group_id) {
                            selectEl.value = data.group_id;
                        }
                    }
                    pollI2V(data.group_id, index);
                } else {
                    statusDiv.innerText = 'ERROR: ' + (data.error || 'Unknown');
                    btn.disabled = false;
                }
            } catch (e) {
                statusDiv.innerText = 'SYSTEM FAILURE: ' + e.message;
                btn.disabled = false;
            }
        }


        // Helper to format logs with images
        function formatLog(logText) {
            // Escape HTML first
            let escaped = logText.replace(/&/g, "&amp;")
                                 .replace(/</g, "&lt;")
                                 .replace(/>/g, "&gt;")
                                 .replace(/"/g, "&quot;")
                                 .replace(/'/g, "&#039;");
            
            // Replace [IMG:url] with <img> tag
            escaped = escaped.replace(/\[IMG:(.*?)\]/g, '<br><img src="$1" style="max-width:200px; display:block; margin:5px 0; border:1px solid #0f0;"><br>');
            
            // Replace newlines with <br>
            return escaped.replace(/\n/g, '<br>');
        }

        // Sector 17 Logic
        async function submitSector17() {
            const input = document.getElementById('sector17Input');
            const status = document.getElementById('sector17Status');
            const btn = document.querySelector('.item-17 .action-btn');
            
            if (!input.value) {
                status.innerText = '请输入台词或关键词';
                return;
            }
            
            status.innerText = 'SUBMITTING...';
            btn.disabled = true;
            status.innerText = ''; // Clear previous logs
            
            try {
                const formData = new FormData();
                formData.append('text', input.value);
                
                const res = await fetch('/sector17_submit', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await res.json();
                
                if (data.status === 'processing') {
                     pollSector17(data.task_id);
                } else {
                    status.innerText = 'ERROR: ' + (data.error || 'Unknown');
                    btn.disabled = false;
                }
            } catch (e) {
                status.innerText = 'SYSTEM FAILURE: ' + e.message;
                btn.disabled = false;
            }
        }

        // Sector 19 Logic
        document.getElementById('sector19Form').onsubmit = async function(e) {
            e.preventDefault();
            const form = this;
            const status = document.getElementById('sector19Status');
            const btn = form.querySelector('button[type="submit"]');
            
            status.innerText = 'UPLOADING...';
            btn.disabled = true;
            status.innerText = '';
            
            try {
                const formData = new FormData(form);
                
                const res = await fetch('/sector19_submit', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await res.json();
                
                if (data.status === 'processing') {
                     pollSector19(data.task_id);
                } else {
                    status.innerText = 'ERROR: ' + (data.error || 'Unknown');
                    btn.disabled = false;
                }
            } catch (e) {
                status.innerText = 'SYSTEM FAILURE: ' + e.message;
                btn.disabled = false;
            }
        };

        // Sector 18 Logic
        async function refreshSector18() {
            const textarea = document.getElementById('sector18Text');
            const status = document.getElementById('sector18Status');
            
            status.innerText = 'FETCHING...';
            try {
                const resp = await fetch('/sector18_get_prompt');
                const data = await resp.json();
                
                if (resp.ok) {
                    textarea.value = data.content;
                    status.innerText = 'UPDATED: ' + new Date().toLocaleTimeString();
                } else {
                    status.innerText = 'ERROR: ' + (data.error || 'Unknown');
                }
            } catch (e) {
                console.error(e);
                status.innerText = 'SYSTEM ERROR: ' + e.message;
            }
        }

        function copySector18() {
            const textarea = document.getElementById('sector18Text');
            const status = document.getElementById('sector18Status');
            
            if (!textarea.value) {
                status.innerText = 'NO CONTENT';
                return;
            }

            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            
            // Try using Clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textarea.value)
                    .then(() => {
                        status.innerText = 'COPIED TO CLIPBOARD';
                        setTimeout(() => { status.innerText = ''; }, 2000);
                    })
                    .catch(err => {
                        console.error('Clipboard API failed:', err);
                        fallbackCopy(textarea, status);
                    });
            } else {
                fallbackCopy(textarea, status);
            }
        }

        function fallbackCopy(textarea, status) {
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    status.innerText = 'COPIED (Fallback)';
                    setTimeout(() => { status.innerText = ''; }, 2000);
                } else {
                    status.innerText = 'COPY FAILED (Fallback)';
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                status.innerText = 'COPY FAILED: ' + err.message;
            }
        }

        // --- Polling Functions (Extracted & Shared) ---

        const pollingRegistry = {
            sector7: { id: null, interval: null },
            sector9: { id: null, interval: null },
            sector10: { id: null, interval: null },
            sector11: { id: null, interval: null },
            sector12: { id: null, interval: null },
            sector17: { id: null, interval: null },
            sector19: { id: null, interval: null }
        };

        function startPolling(key, taskId, intervalFn) {
            if (pollingRegistry[key].id === taskId && pollingRegistry[key].interval) {
                return; // Already polling this task
            }
            
            // Clear previous if any
            if (pollingRegistry[key].interval) {
                clearInterval(pollingRegistry[key].interval);
            }
            
            pollingRegistry[key].id = taskId;
            
            const interval = setInterval(async () => {
                const shouldStop = await intervalFn();
                if (shouldStop) {
                    clearInterval(interval);
                    pollingRegistry[key].interval = null;
                }
            }, 2000);
            
            pollingRegistry[key].interval = interval;
        }

        function pollSector7(promptId) {
            console.log("pollSector7 called with ID:", promptId);
            const statusDiv = document.getElementById('audioStatus');
            const btn = document.getElementById('audioUploadBtn');
            
            if (!statusDiv) return;

            if (pollingRegistry.sector7.id !== promptId) {
                if (!statusDiv.innerText.includes('PROCESSING') && !statusDiv.innerText.includes('SUBMITTING')) {
                     statusDiv.innerText = 'RESTORING SESSION...';
                }
                btn.disabled = true;
            }

            startPolling('sector7', promptId, async () => {
                try {
                    const statusRes = await fetch(`/check_audio_status/${promptId}`);
                    const statusData = await statusRes.json();
                    
                    if (statusData.status === 'completed') {
                        statusDiv.innerText = 'AUDIO GENERATED SUCCESSFULLY.';
                        btn.disabled = false;
                        updateLatestAudio();
                        return true;
                    } else if (statusData.status === 'failed') {
                        statusDiv.innerText = 'FAILED: ' + (statusData.error || 'Unknown');
                        btn.disabled = false;
                        return true;
                    } else {
                        statusDiv.innerText = `PROCESSING... [${statusData.status}]`;
                        return false;
                    }
                } catch (e) {
                    console.error(e);
                    return false;
                }
            });
        }

        function pollI2V(groupId, index) {
            const key = `sector${index}`;
            const statusDiv = document.getElementById(`i2vStatus${index}`);
            const textInput = document.getElementById(`i2vText${index}`);
            if (!textInput) return;
            const btn = textInput.parentElement.querySelector('button');

            if (pollingRegistry[key].id !== groupId) {
                if (!statusDiv.innerText.includes('PROCESSING') && !statusDiv.innerText.includes('SUBMITTING')) {
                    statusDiv.innerText = 'RESTORING SESSION...';
                }
                btn.disabled = true;
            }

            startPolling(key, groupId, async () => {
                try {
                    const r = await fetch(`/check_group_status/${groupId}`);
                    const s = await r.json();
                    
                    if (s.status === 'processing') {
                        statusDiv.innerText = `PROCESSING... [${s.progress || ''}]`;
                        return false;
                    } else {
                        if (s.status === 'completed') {
                            statusDiv.innerText = 'COMPLETED.';
                            updateLatestVideo(true);
                        } else {
                            statusDiv.innerText = 'FAILED: ' + (s.error || 'Unknown');
                        }
                        btn.disabled = false;
                        return true;
                    }
                } catch (e) {
                    return false;
                }
            });
        }

        function pollSector17(taskId) {
            const status = document.getElementById('sector17Status');
            const btn = document.querySelector('.item-17 .action-btn');
            
            if (pollingRegistry.sector17.id !== taskId) {
                if (!status.innerText.includes('SUBMITTING')) {
                     // status.innerText = 'RESTORING SESSION...'; 
                }
                btn.disabled = true;
            }
            
            startPolling('sector17', taskId, async () => {
                 try {
                     const checkRes = await fetch(`/check_sector_task/${taskId}`);
                     const taskData = await checkRes.json();
                     
                     if (taskData.logs && taskData.logs.length > 0) {
                         status.innerHTML = formatLog(taskData.logs.join('\n'));
                         status.scrollTop = status.scrollHeight;
                     }
                     
                     if (taskData.status === 'completed') {
                         status.innerHTML += '<br><br>COMPLETED.';
                         btn.disabled = false;
                         return true;
                     } else if (taskData.status === 'failed') {
                         status.innerHTML += '<br><br>FAILED: ' + (taskData.error || 'Unknown');
                         btn.disabled = false;
                         return true;
                     }
                     return false;
                 } catch (e) {
                     console.error(e);
                     return false;
                 }
             });
        }

        function pollSector19(taskId) {
            const status = document.getElementById('sector19Status');
            const form = document.getElementById('sector19Form');
            const btn = form.querySelector('button[type="submit"]');

            if (pollingRegistry.sector19.id !== taskId) {
                if (!status.innerText.includes('UPLOADING')) {
                    // status.innerText = 'RESTORING SESSION...';
                }
                btn.disabled = true;
            }

            startPolling('sector19', taskId, async () => {
                 try {
                     const checkRes = await fetch(`/check_sector_task/${taskId}`);
                     const taskData = await checkRes.json();
                     
                     if (taskData.logs && taskData.logs.length > 0) {
                         status.innerHTML = formatLog(taskData.logs.join('\n'));
                         status.scrollTop = status.scrollHeight;
                     }
                     
                     if (taskData.status === 'completed') {
                         status.innerHTML += '<br><br>COMPLETED.<br><br>' + formatLog(taskData.result.content || '');
                         btn.disabled = false;
                         return true;
                     } else if (taskData.status === 'failed') {
                         status.innerHTML += '<br><br>FAILED: ' + (taskData.error || 'Unknown');
                         btn.disabled = false;
                         return true;
                     }
                     return false;
                 } catch (e) {
                     console.error(e);
                     return false;
                 }
             });
        }

        // --- Synchronization Logic ---

        let syncDebounceTimer;
        function debounceSync(sector, updates) {
            clearTimeout(syncDebounceTimer);
            syncDebounceTimer = setTimeout(() => {
                updateGlobalState(sector, updates);
            }, 500);
        }

        async function updateGlobalState(sector, updates) {
            try {
                await fetch('/api/sync_state', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sector, updates })
                });
            } catch (e) {
                console.error('Sync failed:', e);
            }
        }

        async function restoreState() {
            try {
                const res = await fetch('/api/sync_state');
                const state = await res.json();
                
                // Sector 7 (Audio)
                if (state.sector7) {
                    const input = document.querySelector('#audioUploadForm input[name="text"]');
                    if (input && state.sector7.text && input !== document.activeElement) {
                         if (input.value !== state.sector7.text) input.value = state.sector7.text;
                    }
                    
                    if (state.sector7.emotions) {
                        state.sector7.emotions.forEach(emo => {
                            const cb = document.querySelector(`input[name="emotions"][value="${emo}"]`);
                            if (cb && !cb.matches(':focus')) cb.checked = true;
                        });
                    }

                    if (state.sector7.latest_task_id) {
                        pollSector7(state.sector7.latest_task_id);
                    }
                }

                // Sector 9-12 (I2V)
                [9, 10, 11, 12].forEach(i => {
                    const sKey = `sector${i}`;
                    if (state[sKey]) {
                        const input = document.getElementById(`i2vText${i}`);
                        if (input && state[sKey].text && input !== document.activeElement) {
                            if (input.value !== state[sKey].text) input.value = state[sKey].text;
                        }
                        
                        if (state[sKey].latest_task_id) {
                            pollI2V(state[sKey].latest_task_id, i);
                        }
                    }
                });

                // Sector 17
                if (state.sector17) {
                    const input = document.getElementById('sector17Input');
                    if (input && state.sector17.text && input !== document.activeElement) {
                        if (input.value !== state.sector17.text) input.value = state.sector17.text;
                    }
                    
                    if (state.sector17.latest_task_id) {
                        pollSector17(state.sector17.latest_task_id);
                    }
                }

                // Sector 19 (Logs only, file cannot be synced)
                if (state.sector19 && state.sector19.latest_task_id) {
                    pollSector19(state.sector19.latest_task_id);
                }

            } catch (e) {
                console.error('Restore state failed:', e);
            }
        }

        // Attach Listeners
        document.addEventListener('DOMContentLoaded', () => {
            restoreState();
            setInterval(restoreState, 2000); // Poll for sync updates every 2s

            // Sector 7 Input
            const audioInput = document.querySelector('#audioUploadForm input[name="text"]');
            if (audioInput) {
                audioInput.addEventListener('input', (e) => {
                    const emotions = Array.from(document.querySelectorAll('input[name="emotions"]:checked')).map(cb => cb.value);
                    debounceSync('sector7', { text: e.target.value, emotions });
                });
            }
            document.querySelectorAll('input[name="emotions"]').forEach(cb => {
                cb.addEventListener('change', () => {
                     const text = document.querySelector('#audioUploadForm input[name="text"]').value;
                     const emotions = Array.from(document.querySelectorAll('input[name="emotions"]:checked')).map(cb => cb.value);
                     debounceSync('sector7', { text, emotions });
                });
            });

            // Sector 9-12 Inputs
            [9, 10, 11, 12].forEach(i => {
                const input = document.getElementById(`i2vText${i}`);
                if (input) {
                    input.addEventListener('input', (e) => {
                        debounceSync(`sector${i}`, { text: e.target.value });
                    });
                }
            });

            // Sector 17 Input
            const s17Input = document.getElementById('sector17Input');
            if (s17Input) {
                s17Input.addEventListener('input', (e) => {
                    debounceSync('sector17', { text: e.target.value });
                });
            }
        });
    </script>
</body>
</html>
