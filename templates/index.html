<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker Grid</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <button id="refresh-btn" onclick="location.reload()" title="Refresh Page">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
        </svg>
    </button>
    <div class="grid-container">
        <!-- Ê†ºÂ≠ê 1 -->
        <div class="grid-item item-1">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2>Â≠óÁ¨¶ÊõøÊç¢</h2>
                <div style="height: 40%;">
                    <form method="POST" action="/">
                        <div class="input-group">
                            <input type="text" name="text" placeholder=">_" autocomplete="off" autofocus>
                            <button type="submit" name="action" value="add">+</button>
                            <button type="submit" name="action" value="remove">-</button>
                        </div>
                    </form>
                </div>
                <div style="height: 60%; border-top: 1px solid var(--border-color); overflow-y: auto; padding-top: 5px;">
                     <div class="substitution-content" style="word-break: break-all;">
                        {{ substitutions }}
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Ê†ºÂ≠ê 2: ÁΩëÁªúËøûÈÄöÊÄß -->
        <div class="grid-item item-2">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2 style="display: flex; align-items: center;">
                    ÁΩëÁªúËøûÈÄöÊÄß
                    <span id="connStatusLight" style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: gray; box-shadow: 0 0 2px gray; margin-left: 10px;"></span>
                </h2>
                <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div style="font-size: 0.8rem; margin-bottom: 10px; color: #888;">CURRENT IP</div>
                    <div id="currentIp" style="font-size: 1.1rem; color: #0f0; margin-bottom: 20px; font-weight: bold; word-break: break-all; text-align: center;">LOADING...</div>
                    <button id="retestBtn" class="action-btn" onclick="retestConnection()" style="width: 80%;">RETEST CONNECTION</button>
                    <div id="retestStatus" style="font-size: 0.7rem; margin-top: 5px; height: 1em;"></div>
                </div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 3: ËßíËâ≤ÈÖçÁΩÆ (Âéü Grid 2) -->
        <div class="grid-item item-3">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2>ËßíËâ≤ÈÖçÁΩÆ</h2>
                <div style="margin-top: 5px; font-size: 0.8rem; color: #ff0000;">ÂΩìÂâçËßíËâ≤</div>
                <form id="charUploadForm" action="/upload_character" method="post" enctype="multipart/form-data">
                    <input type="file" name="file" accept="image/png, image/jpeg, image/webp" 
                           class="upload-input">
                    <button type="submit" id="charUploadBtn" class="action-btn">UPLOAD CHARACTER</button>
                </form>
                <div id="charStatus" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 4: ÁªìÊûúÂ±ïÁ§∫ & ËßíËâ≤È¢ÑËßà (Âéü Grid 3) -->
        <div class="grid-item item-4">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2>ÂΩìÂâçËßíËâ≤ <span style="cursor: pointer; margin-left: 5px;" onclick="refreshCharacter()">üîÑ</span></h2>
                <div id="outputContainer" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <!-- Character Preview (Initially Hidden) -->
                    <img id="charPreview" src="http://obs.dimond.top/character.png" 
                         style="max-width: 90%; max-height: 90%; border: 1px solid #00ff00; object-fit: contain; display: none;"
                         onload="this.style.display='block'"
                         onerror="this.style.display='none'">
                    <!-- Video Output will be injected here via JS -->
                </div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 5: ËßÜÈ¢ëÊç¢‰∫∫ (Âéü Grid 6) -->
        <div class="grid-item item-5">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2>ËßÜÈ¢ëÊç¢‰∫∫</h2>
                <form id="uploadForm" action="/upload_and_cut" method="post" enctype="multipart/form-data">
                    <div style="margin-bottom: 5px;">
                        <label style="margin-right: 10px;"><input type="radio" name="workflow_type" value="real" checked> Áúü‰∫∫</label>
                        <label><input type="radio" name="workflow_type" value="anime"> Âä®Êº´</label>
                    </div>
                    <input type="file" name="video" accept="video/*" class="upload-input">
                    <button type="submit" id="uploadBtn" class="action-btn">EXECUTE</button>
                </form>
                <div id="uploadStatus" style="margin-top: 10px; font-size: 0.8em; white-space: pre-wrap; word-break: break-all;"></div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 6: ÊúÄÊñ∞ËßÜÈ¢ëÈ¢ÑËßà (Âéü Grid 7) -->
        <div class="grid-item item-6">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2><a href="http://obs.dimond.top" target="_blank" style="color: inherit; text-decoration: none;">ÂΩìÂâçËßÜÈ¢ë</a> <span style="cursor: pointer; margin-left: 5px;" onclick="updateLatestVideo(true)">üîÑ</span></h2>
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <video id="latestVideoPreview" preload="metadata" autoplay muted loop controls style="width: 100%; height: 100%; object-fit: contain; border: 1px solid #00ff00; background: #000;">
                        Your browser does not support the video tag.
                    </video>
                </div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 7: Èü≥È¢ë‰∏ä‰º† (Êñ∞Â¢û) -->
        <div class="grid-item item-7">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2>Èü≥È¢ëÁîüÊàê</h2>
                <form id="audioUploadForm" action="/upload_audio" method="post" enctype="multipart/form-data">
                    <div style="margin-bottom: 5px; display: flex; gap: 5px; align-items: center;">
                        <input type="text" name="text" placeholder="ËæìÂÖ•ÁîüÊàêÁöÑÊñáÊú¨" class="upload-input" style="flex-grow: 1; box-sizing: border-box; margin-bottom: 0;" required>
                        <button type="submit" id="audioUploadBtn" class="action-btn" style="white-space: nowrap;">GENERATE AUDIO</button>
                    </div>
                    
                    <!-- ÊÉÖÊÑüÈÄâÊã© Checkboxes -->
                    <div style="margin-bottom: 5px; font-size: 0.8em; display: flex; flex-wrap: wrap; gap: 5px;">
                        <label><input type="checkbox" name="emotions" value="Happy"> Happy</label>
                        <label><input type="checkbox" name="emotions" value="Angry"> Angry</label>
                        <label><input type="checkbox" name="emotions" value="Sad"> Sad</label>
                        <label><input type="checkbox" name="emotions" value="Fear"> Fear</label>
                        <label><input type="checkbox" name="emotions" value="Hate"> Hate</label>
                        <label><input type="checkbox" name="emotions" value="Low"> Low</label>
                        <label><input type="checkbox" name="emotions" value="Surprise"> Surprise</label>
                        <label><input type="checkbox" name="emotions" value="Neutral"> Neutral</label>
                    </div>
                    
                    <input type="file" name="file" accept="audio/*, .mov, .mp4" class="upload-input">
                </form>
                <div id="audioStatus" style="margin-top: 5px; font-size: 0.7em; white-space: pre-wrap;"></div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 10: ÊúÄÊñ∞Èü≥È¢ëÂ±ïÁ§∫ (Êñ∞Â¢û) -->
        <div class="grid-item item-10">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2><a href="http://obs.dimond.top" target="_blank" style="color: inherit; text-decoration: none;">ÂΩìÂâçÈü≥È¢ë</a> <span style="cursor: pointer; margin-left: 5px;" onclick="updateLatestAudio(true)">üîÑ</span></h2>
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <audio id="latestAudioPreview" controls style="width: 90%;">
                        Your browser does not support the audio element.
                    </audio>
                    <div id="latestAudioName" style="margin-top: 10px; font-size: 0.7em; word-break: break-all;"></div>
                </div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 11: ÂõæÁâáÊç¢‰∫∫ (Êñ∞Â¢û) -->
        <div class="grid-item item-11">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2>ÂõæÁâáÊç¢‰∫∫</h2>
                <form id="imgSwapForm" action="/upload_image_swap" method="post" enctype="multipart/form-data">
                    <div style="margin-bottom: 5px;">
                        <label style="margin-right: 10px;"><input type="radio" name="workflow_type" value="real" checked> Áúü‰∫∫</label>
                        <label><input type="radio" name="workflow_type" value="anime"> Âä®Êº´</label>
                    </div>
                    <input type="file" name="file" accept="image/*" class="upload-input">
                    <button type="submit" id="imgSwapBtn" class="action-btn">EXECUTE</button>
                </form>
                <div id="imgSwapStatus" style="margin-top: 10px; font-size: 0.8em; white-space: pre-wrap; word-break: break-all;"></div>
            </div>
        </div>

        <!-- Ê†ºÂ≠ê 12: ÂΩìÂâçÂõæÁâá (Êñ∞Â¢û) -->
        <div class="grid-item item-12">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <h2><a href="http://obs.dimond.top" target="_blank" style="color: inherit; text-decoration: none;">ÂΩìÂâçÂõæÁâá</a> <span style="cursor: pointer; margin-left: 5px;" onclick="updateLatestImage(true)">üîÑ</span></h2>
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <img id="latestImagePreview" src="" style="max-width: 90%; max-height: 90%; border: 1px solid #00ff00; object-fit: contain; display: none;" 
                         onload="this.style.display='block'" 
                         onerror="this.style.display='none'">
                    <div id="latestImageName" style="margin-top: 10px; font-size: 0.7em; word-break: break-all;"></div>
                </div>
            </div>
        </div>

        <!-- ÂÖ∂‰ªñÊ†ºÂ≠êÂç†‰Ωç -->
        {% for i in range(13, 17) %}
        <div class="grid-item item-{{ i }}">
            <div class="grid-controls">
                <button class="control-btn control-btn-full" onclick="goFullscreen(this.closest('.grid-item'))">[FULL]</button>
                <button class="control-btn control-btn-back" onclick="exitFullscreen(this.closest('.grid-item'))">[BACK]</button>
            </div>
            <div class="grid-content">
                <span class="placeholder">SECTOR {{ "%02d"|format(i) }}</span>
            </div>
        </div>
        {% endfor %}
    </div>

    <script>
        // Fullscreen Logic
        function goFullscreen(elem) {
            elem.classList.add('fullscreen');
        }

        function exitFullscreen(elem) {
            elem.classList.remove('fullscreen');
        }

        // Video cache to prevent repeated loading
        const videoCache = new Map();

        // Check ComfyUI Status
        function checkComfyStatus() {
            fetch('/comfy_status')
                .then(response => response.json())
                .then(data => {
                    const dot = document.getElementById('connStatusLight');
                    const ipDiv = document.getElementById('currentIp');
                    
                    if (data.status === 'online') {
                        dot.style.backgroundColor = '#00ff00'; // Green
                        dot.style.boxShadow = '0 0 5px #00ff00';
                        ipDiv.innerText = data.ip || 'Unknown';
                        ipDiv.style.color = '#00ff00';
                    } else {
                        dot.style.backgroundColor = '#ff0000'; // Red
                        dot.style.boxShadow = '0 0 5px #ff0000';
                        ipDiv.innerText = data.ip || 'DISCONNECTED';
                        ipDiv.style.color = '#ff0000';
                    }
                })
                .catch(err => {
                    console.error('Status check failed:', err);
                    const dot = document.getElementById('connStatusLight');
                    const ipDiv = document.getElementById('currentIp');
                    dot.style.backgroundColor = 'gray';
                    ipDiv.innerText = 'ERROR';
                    ipDiv.style.color = 'gray';
                });
        }
        
        function retestConnection() {
            const btn = document.getElementById('retestBtn');
            const statusDiv = document.getElementById('retestStatus');
            btn.disabled = true;
            statusDiv.innerText = 'TESTING...';
            
            fetch('/retest_connection', { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                         statusDiv.innerText = 'DONE';
                         checkComfyStatus(); // Refresh UI
                    } else {
                        statusDiv.innerText = 'FAILED';
                    }
                })
                .catch(e => {
                    statusDiv.innerText = 'ERROR: ' + e.message;
                })
                .finally(() => {
                    btn.disabled = false;
                    setTimeout(() => { statusDiv.innerText = ''; }, 3000);
                });
        }
        
        // Check immediately and then every 30 seconds
        checkComfyStatus();
        setInterval(checkComfyStatus, 30000);

        // Character Upload Handler
        document.getElementById('charUploadForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('charStatus');
            const btn = document.getElementById('charUploadBtn');
            const preview = document.getElementById('charPreview');
            
            statusDiv.innerText = 'UPLOADING...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_character', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                
                if (response.ok) {
                    statusDiv.innerText = 'UPLOAD SUCCESS.';
                    // Update preview with cache busting
                    if (preview) {
                        preview.src = result.url + '?t=' + new Date().getTime();
                        preview.style.display = 'block';
                    }
                } else {
                    statusDiv.innerText = 'ERROR: ' + (result.error || 'Unknown');
                }
            } catch (err) {
                statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
            } finally {
                btn.disabled = false;
            }
        };

        // Video Upload Handler
        document.getElementById('uploadForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('uploadStatus');
            const btn = document.getElementById('uploadBtn');
            
            statusDiv.innerText = 'INITIALIZING UPLOAD...\nTARGET: COMFYUI NODE';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_and_cut', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                
                if (response.ok) {
                     statusDiv.innerText = 'UPLOAD SUCCESS. PROCESSING SEQUENCE INITIATED...';
                     
                     // Start polling
                     const groupId = result.group_id;
                     const pollInterval = setInterval(async () => {
                         try {
                             const statusRes = await fetch(`/check_group_status/${groupId}`);
                             const statusData = await statusRes.json();
                             
                             if (statusData.status === 'processing') {
                                 statusDiv.innerText = `PROCESSING... [${statusData.progress}]`;
                             } else if (statusData.status === 'completed') {
                                 clearInterval(pollInterval);
                                statusDiv.innerText = 'SEQUENCE COMPLETED.\nESTABLISHING LINK TO SECTOR 04...';
                                btn.disabled = false;
                                
                                // Display video in Sector 04 (replacing character preview or appending?)
                                // Request says Grid 4 should display the result. 
                                // We can replace the content of outputContainer or hide charPreview.
                                const outputContainer = document.getElementById('outputContainer');
                                const charPreview = document.getElementById('charPreview');
                                if (charPreview) charPreview.style.display = 'none'; // Hide char preview
                                
                                // Remove old video if exists
                                const oldVideo = outputContainer.querySelector('video');
                                if (oldVideo) oldVideo.remove();
                                
                                const videoContainer = document.createElement('div');
                                videoContainer.innerHTML = `
                                    <h2>OUTPUT FEED</h2>
                                    <video controls preload="metadata" autoplay muted loop style="width: 100%; max-height: 200px; border: 1px solid #00ff00; background: #000;">
                                        <source src="${statusData.final_url}" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>
                                    <div style="margin-top: 5px; font-size: 0.7em; word-break: break-all;">${statusData.final_url}</div>
                                `;
                                outputContainer.appendChild(videoContainer);
                                
                            } else {
                                 clearInterval(pollInterval);
                                 statusDiv.innerText = 'FAILED: ' + (statusData.error || 'Unknown error');
                                 btn.disabled = false;
                             }
                         } catch (e) {
                             console.error(e);
                             // Don't stop polling on transient network errors, but maybe show warning?
                         }
                     }, 2000);
                     
                 } else {
                     statusDiv.innerText = 'ERROR: ' + (result.error || 'Unknown');
                     btn.disabled = false;
                 }
             } catch (err) {
                 statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
                 btn.disabled = false;
             }
         };

        // Fetch latest video for Grid 7
        function updateLatestVideo(force = false) {
            fetch('/latest_video')
                .then(response => response.json())
                .then(data => {
                    if (data.url) {
                        const video = document.getElementById('latestVideoPreview');
                        // Only update if source changed to avoid flickering, unless forced
                        if (force || !video.src.includes(data.url)) {
                            // Add timestamp if forced or just to be safe if url is same
                            const newSrc = force ? data.url + "?t=" + new Date().getTime() : data.url;
                            if (video.src !== newSrc) {
                                // Pause current video before changing source to prevent stuttering
                                const wasPaused = video.paused;
                                const currentTime = video.currentTime; // Preserve playback position
                                video.pause();
                                
                                // Use video caching to improve performance
                                if (videoCache.has(newSrc)) {
                                    video.src = videoCache.get(newSrc);
                                } else {
                                    video.src = newSrc;
                                    // Cache the source URL for future reference
                                    videoCache.set(newSrc, newSrc);
                                }
                                
                                // Restore playback state if video was playing
                                if (!wasPaused && force) {
                                    video.currentTime = currentTime; // Restore position
                                    video.play().catch(e => console.log('Auto-play prevented by browser policies'));
                                }
                            }
                        }
                    }
                })
                .catch(err => console.error('Error fetching latest video:', err));
        }
        
        // Check for latest video every 30 seconds
        updateLatestVideo();
        setInterval(updateLatestVideo, 30000);

        // Character Refresh Logic
        function refreshCharacter() {
            const preview = document.getElementById('charPreview');
            if (preview) {
                preview.src = "http://obs.dimond.top/character.png?t=" + new Date().getTime();
                preview.style.display = 'block';
            }
        }

        // Audio Upload Handler
        document.getElementById('audioUploadForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('audioStatus');
            const btn = document.getElementById('audioUploadBtn');
            
            statusDiv.innerText = 'INITIALIZING AUDIO GENERATION...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_audio', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                
                if (response.ok) {
                    statusDiv.innerText = 'SUBMITTED. PROCESSING...';
                    
                    // Poll for status
                    const promptId = result.prompt_id;
                    const pollInterval = setInterval(async () => {
                        try {
                            const statusRes = await fetch(`/check_audio_status/${promptId}`);
                            const statusData = await statusRes.json();
                            
                            if (statusData.status === 'completed') {
                                clearInterval(pollInterval);
                                statusDiv.innerText = 'AUDIO GENERATED SUCCESSFULLY.';
                                btn.disabled = false;
                                // Update preview
                                updateLatestAudio();
                            } else if (statusData.status === 'failed') {
                                clearInterval(pollInterval);
                                statusDiv.innerText = 'FAILED: ' + (statusData.error || 'Unknown');
                                btn.disabled = false;
                            } else {
                                statusDiv.innerText = `PROCESSING... [${statusData.status}]`;
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }, 2000);
                    
                } else {
                    statusDiv.innerText = 'ERROR: ' + (result.error || 'Unknown');
                    btn.disabled = false;
                }
            } catch (err) {
                statusDiv.innerText = 'SYSTEM FAILURE: ' + err.message;
                btn.disabled = false;
            }
        };

        // Fetch latest audio for Grid 10
        function updateLatestAudio(force = false) {
            fetch('/latest_audio')
                .then(response => response.json())
                .then(data => {
                    if (data.url) {
                        const audio = document.getElementById('latestAudioPreview');
                        const nameDiv = document.getElementById('latestAudioName');
                        // Only update if source changed
                        if (force || !audio.src.includes(data.url)) {
                            const newSrc = force ? data.url + "?t=" + new Date().getTime() : data.url;
                            if (audio.src !== newSrc) {
                                audio.src = newSrc;
                                nameDiv.innerText = data.filename || 'sound.flac';
                            }
                        }
                    }
                })
                .catch(err => console.error('Error fetching latest audio:', err));
        }

        // Check for latest audio every 30 seconds
        updateLatestAudio();
        setInterval(updateLatestAudio, 30000);

        // Image Swap Logic
        document.getElementById('imgSwapForm').onsubmit = async function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const statusDiv = document.getElementById('imgSwapStatus');
            const btn = document.getElementById('imgSwapBtn');
            
            statusDiv.innerText = 'PROCESSING...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/upload_image_swap', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.innerText = `Started: ${data.group_id}\nMonitoring...`;
                    pollImgSwapStatus(data.group_id);
                } else {
                    statusDiv.innerText = `Error: ${data.error}`;
                    btn.disabled = false;
                }
            } catch (err) {
                statusDiv.innerText = `Error: ${err.message}`;
                btn.disabled = false;
            }
        };

        function pollImgSwapStatus(groupId) {
            const statusDiv = document.getElementById('imgSwapStatus');
            const btn = document.getElementById('imgSwapBtn');
            
            const interval = setInterval(async () => {
                try {
                    const response = await fetch(`/check_group_status/${groupId}`);
                    const data = await response.json();
                    
                    if (data.status === 'completed') {
                        clearInterval(interval);
                        statusDiv.innerText = `COMPLETED\nURL: ${data.final_url}`;
                        btn.disabled = false;
                        updateLatestImage(); // Refresh preview
                    } else if (data.status === 'failed') {
                        clearInterval(interval);
                        statusDiv.innerText = `FAILED: ${data.error}`;
                        btn.disabled = false;
                    } else {
                        // processing
                        statusDiv.innerText = `Processing...`;
                    }
                } catch (err) {
                    console.error("Poll error", err);
                }
            }, 5000);
        }

        // Latest Image Logic
        function updateLatestImage(force = false) {
            fetch('/latest_image')
                .then(r => r.json())
                .then(data => {
                    const img = document.getElementById('latestImagePreview');
                    const name = document.getElementById('latestImageName');
                    if (data.url) {
                        // Add timestamp to prevent caching
                        // If force is true, we update the timestamp even if url is same
                        // But wait, the previous code already added timestamp? 
                        // "img.src = data.url + "?t=" + new Date().getTime();"
                        // Yes, it was always adding timestamp on load.
                        // But if we call this function and src hasn't changed (ignoring query param), browser might not reload?
                        // Actually, if we generate a NEW timestamp, it will reload.
                        
                        // We need to check if base URL matches to avoid unnecessary reload loop if we were polling?
                        // The original code: img.src = data.url + "?t=" + new Date().getTime();
                        // This unconditionally reloads the image every 30s. This causes flickering.
                        
                        // Let's improve this: only reload if filename changed OR force is true.
                        
                        const currentSrc = img.src.split('?')[0]; // Remove existing timestamp
                        
                        if (force || currentSrc !== data.url) {
                             img.src = data.url + "?t=" + new Date().getTime();
                             name.innerText = data.filename;
                             img.style.display = 'block';
                        }
                    } else {
                        img.style.display = 'none';
                        name.innerText = "No image found";
                    }
                })
                .catch(e => console.error("Error fetching latest image:", e));
        }
        
        // Initial load and poll
        updateLatestImage();
        setInterval(updateLatestImage, 30000);

    </script>
</body>
</html>